
================
What is avrtest?
================

avrtest is a free software simulator for the Atmel AVR family of
microcontrollers distributed under the GNU General Public License.

The main intention of avrtest is to supply a fast, easy-to-use simulator
to run the GCC testsuite for avr-gcc.  Thus, its main audience are guys
that develop parts of the AVR toolchain like avr-gcc or avr-libc.

avrtest is an instruction set simulator for AVR core families
    avr51: ATmega128*, AT90can128, AT90usb128*
    avr6:  ATmega256*

avrtest-xmega is an instruction set simulator for AVR XMEGA core families
    avrxmega6: ATXmega128*, ...

The exectuable that supports AVR XMEGA cores is named avrtest-xmega.
In addition to the avrtest simulator, it supports the XMEGA instructions
XCH, LAS, LAC and LAT.

In the remainder, avrtest is explained.  avrtest-xmega works similar.
avrtest does not simulate internal peripherals like timers, I/O ports,
interrupts, etc. 

================
Special features
================

The simulator has builtin capability of writing to stdout when a value
is written to a destinct memory location.  For example, an easy hello world
program for AVR could look like this:


#include <stdio.h>

int main (void)
{
    printf ("Hallo World!\n");
    return 0;
}


Compile this program as usual but link against exit-atmega128.o. 
How to build that object is explained in the next chapter. Store the
C source as hello.c and compile it with, e.g.

  $ avr-gcc hello.c -O -mmcu=atmega128 -o hello.elf /someplace/avrtest/exit-atmega128.o

The exit-*.o object arranges the putchar function to write to the mentioned
location.  avrtest will pick the value and print it to standard output of
your host computer.  To start the program, type

    avrtest -mmcu=avr51 hello.elf

This will print something like


Hallo World!

 exit status: EXIT
      reason: exit function called
     program: hello.elf
exit address: 00011c
total cycles: 806


You can also write to the magic locations directly:


#include "avrtest.h"

int main (void)
{
    char c;
    
    STDOUT_PORT = 'Q';

    c = STDIN_PORT;
    STDOUT_PORT = c+1;
    
    return 0;
}


avrtest.h defines the port locations. Compile the C source with

    avr-gcc inout.c -O -mmcu=atmega128 -o inout.elf -I /someplace/avrtest

When running the program with

    avrtest -mmcu=avr51 inout.elf

The simulator will print a 'Q' on the console and wait for input. 
Type '1<Enter>' and the output will be

Q1
2
 exit status: EXIT
      reason: infinite loop detected (normal exit)
     program: inout.elf
exit address: 0000b8
total cycles: 30


There are more magic ports to control logging and help performance
measurements, see the respective sections below.


=================================================
Running avr-gcc testsuite using avrtest simulator
=================================================

http://lists.gnu.org/archive/html/avr-gcc-list/2009-09/msg00016.html

* Get avr-gcc, binutils and avr-libc built from sources and working.

* Install dejagnu, expect and TCL

* Unpack the avrtest tar file from WinAVR sources top "someplace".
  You find a link to the package at "Download Snapshot" on
  https://sourceforge.net/p/winavr/code/HEAD/tree/trunk/avrtest/

* Run

    make
  
  inside /someplace/avrtest which will build executables from avrtest.c
  and avr object file exit-atmega128.o from dejagnuboards/exit.c.

* To build exit*.o modules, avr-gcc will be used.  If you want a different
  avr-gcc not found in PATH, use:
  
    make clean-exit all CC_FOR_AVR=/some-compiler-path/avr-gcc

* Copy /someplace/avrtest/.dejagnurc to your $HOME and change the path
  inside to point to directory where "board file" is located.
  This is dejagnuboards subdirectory of avrtest files:

    set board dir /someplace/avrtest/dejagnuboards

* Edit /someplace/avrtest/dejagnuboards/atmega128-sim.exp and replace paths
  to point to correct location of files for simulator (avrtest executable
  and exit-atmega128.o object file) or add avrtest to $PATH:

    set result [exec /someplace/avrtest/avrtest -m 2000000000 -no-stdin $prog ]

    set board_info ldflags "/someplace/avrtest/exit-atmega128.o" -Wl,-u,vfprintf ...

* Run the tests from gcc subdirectory of your avr-gcc build directory like:

    make -k check-gcc RUNTESTFLAGS="--target_board=atmega128-sim"
    make -k check-gcc RUNTESTFLAGS="--target_board=atxmega128-sim"

* Look in the ./gcc/testsuite subdirectory of avr-gcc build directory for
  logged results or add the -all switch to see it working 1 test at a time.

    make -k check RUNTESTFLAGS="--target_board=atmega128-sim -all"

* You can run parts of the testsuite like this:

    make -k check RUNTESTFLAGS="--target_board=atmega128-sim avr.exp"
    make -k check RUNTESTFLAGS="--target_board=atmega128-sim avr-torture.exp=pr418854.c"

Voila!



=============================================
 -q : Quiet operation
=============================================

With -q turned on avrtest will print no messages except the ones
explicitly requested by:
  - -runtime
  - LOG_U8 (X), PERF_DUMP_ALL and similar logging commands, see below.


The following exit stati will be returned with -q:
  -  0  Everything went fine.
  -  1  Target program called abort()  resp. wrote to ABORT_PORT.
  -  x  Target program called exit (x) resp. wrote x to EXIT_PORT.

  - 10  Program timeout as set by -m MAXCOUNT.
  - 11  Executable could not be found / read, is too big or
        its format is invalid etc.
  - 12  Out of memory reading symbol table (avrtest_log only).
  - 13  Wrong avrtest usage: Unknown options, etc.

  - 42  Fatal error in avrtest.


=============================================
 -args ... : passing arguments to the program
=============================================

* This feature is only supported by avrtest_log and avrtest-xmega_log.

All arguments after -args will be passed to the target program as if the
program was running from the command line.  This is accomplished by startup
code from exit.c located in section .init8 right before main is called.
If you have own startup code in .init8 make sure it will be located before
the code from exit.c, e.g. by appropriate order of the objects passed to
the linker.

The first argument (argv[0]) is the program name with directories
stripped off to save space.  The last argument argv[argc] is set to NULL.

The feature works by writing 3 values to LOG_PORT in exit.c:

    LOG_GET_ARGS_CMD, <ADDR_LOW>, <ADDR_HIGH>

LOG_GET_ARGS_CMD is defined in avrtest.h.  The next two bytes
are the address where to drop the arguments following -args.

After these 3 bytes are written to LOG_PORT, the simulator transfers the
arguments to RAM and sets R24 to argc and R22 to argv so that you can write


int main (int argc, char *argv[])
{
    ...
}


and use argc and argv as in any hosted application.

exit.c:init_args() requests the command args to be put at <ADDR> = 0xf000.
If you prefer a different address then simply adjust exit.c.


========
-no-args
========

will skip all arguments thereafter and set argc = 0 and argv[0] = NULL.

The start-up code in exit.c detects whether the code is executed by
avrtest or by avrtest_log.  If avrtest executes the code (and hence
-[no-]args is ignored) the startup code sets argc = 0 and argv[0] = NULL.

Thus you can test in the program what simulator is executing it by
testing on argc != 0 provided you run the simulator with -args.


=========================================
 -no-log and logging control via LOG_PORT
=========================================

* This feature is only supported by avrtest_log and avrtest-xmega_log.

avrtest_log will log address and action of each executed instruction to
standard output of the host.  In cases where that is too much a flood of
information, you can start avrtest_log with -no-log and turn on instruction
logging by executing special commands defined in avrtest.h:

    LOG_ON;

Turn on instruction logging.

    LOG_OFF;

Turn it off again.

    LOG_SET (N);

Turn on logging for the next N instructions and then switch it off again.

    LOG_PERF;

Turn on logging during performance measurement described below, i.e.
if any timer is in a START / STOP round.

Please notice that this method of switching logging on / off is (low)
intrusive to the program.  The commands listed above are translated by
the compiler to machine instructions that might affect code generation
for the sourrounding code (register allocation, jump offsets, ...).
The command have low overhead; usually it's just one LDI and one
OUT instruction to LOG_PORT.


===================================================
 Logging values to the host computer using LOG_PORT
===================================================

* This feature is only supported by avrtest_log and avrtest-xmega_log.

In order to get values out of the running program the following commands
might be useful:

    LOG_U8 (X);         print X as unsigned 8-bit decimal value
    LOG_S8 (X);         print X as signed 8-bit decimal value
    LOG_X8 (X);         print X as unsigned 8-bit hexadecimal value

Besides these you can use similar commands for wider values with
16, 24 and 32 bits, e.g.

    LOG_U16 (X);
    LOG_X32 (X);

etc.  Moreover, there are the following commands:

    LOG_STR (X);        log string X located in RAM
    LOG_PSTR (X);       log string X located in Flash
    LOG_FLOAT (X);      log float X
    LOG_ADDR (X);       log address X


All of these logging command LOG_XXX have variants that take a custom
printf format string to print the supplied value:

    LOG_FMT_XXX (F, X);    log X using format string F located in RAM
    LOG_PFMT_XXX (F, X);   log X using format string F located in Flash

!!! Please use formatz strings with care!  You can easily crash avrtest_log
!!! and make it raise a Segmentation Fault or other undefined behaviour
!!! by specifying a format string that does not fit the value!

avrtest_log uses "double" to represent float and "unsigned int" for all
other values.  The default format strings for the vanilla LOG_XXX are:

    " %u "              for the "U" variants
    " %d "              for the "S" variants
    " 0x%02x "          for the 8-bit "X" variants
    ...                 ...
    " 0x%08x "          for the 32-bit "X" variants
    "%s"                for strings
    " %.6f "            for floats
    " 0x%04x "          for addresses


=======================================
 Performance measurement using LOG_PORT
=======================================

* This feature is only supported by avrtest_log and avrtest-xmega_log.

The simulator supports 7 independently operating performance-meters:

    PERF_START (N);

Starts perf-meter N which will start capturing values of the
running program like program counter, instruction count, stack pointer,
call depth, etc.

    PERF_STOP (N);

will halt the perf-meter.  Upon encountering the next PERF_START(N)
the meter will be re-enabled and proceed.  The collected values can
be dumped at any time by

    PERF_DUMP (N);

This will show a summary of the extremal values for the perf-meter and
reset it completely so that you can use it for a different task afterwards.
Displayed values are:

 - Calls (abs):  The absolute call depth (CALLs increment, RETs decrement).
 - Calls (rel):  Call depth relative to the starting point.
 - Stack (abs):  Values of the stack pointer (SP).
 - Stack (rel):  Stack usage relative to the starting point.

In order to give a specific perf-meter a more descriptive name there are

    PERF_LABEL (L);
    PERF_PLABEL (L);

where L is a label residing in RAM or Flash, respectively.
avrtest_log will cache the label so you can override it after PERF_LABEL.

If you want to find out what value lead to the round with mimimal or maximal
instruction cycles, each round can be tagged with a value:

    PERF_TAG_STR (N, STR);      Tag perf-meter N with string STR
    PERF_TAG_U16 (N, U);        ... with a 16-bit unsigned integer U
    PERF_TAG_U32 (N, U);        ... with a 32-bit unsigned integer U
    PERF_TAG_FLOAT (N, F);      ... with float F

Just like with LOG_XXX(), U16 and U32 are represented internally as
"unsigned int" and the float as "double".  The default format strings to
print the tags are "%s", " %u ", " %u " and " %.6f " respectively.

Custom format strings can be supplied by

    PERF_TAG_FMT_U16 (N, FMT, U);
    PERF_TAG_PFMT_U16 (N, FMT, U);

with a format string FMT located in RAM resp. Flash.  Thus, the
command to use a signed 32-bit value as tag for the respective
round of perf-meter 1 could read

    PERF_TAG_FMT_U32 (1, " %d ", n);

Example:


#include <math.h>
#include "avrtest.h"

float x, y;

int main (void)
{
    PERF_LABEL (1, "resource consumption of sin()");

    for (x = 0.0; x <= 3.14159; x += 0.01)
    {
        PERF_TAG_FMT_FLOAT (1, " sin (%.5f) ", x);
        PERF_START (1);
        y = sin (x);
        PERF_STOP (1);

        PERF_TAG_FMT_FLOAT (2, " x=%.5f ", x);
        PERF_STAT_FLOAT (2, fabs (x * (1 - x*x / 6) - y));
    }

    PERF_DUMP_ALL;
    return 0;
}


Compile as usual and link against exit-***.o.  Running

  $ avrtest_log ... -no-log -q

produces an output like


--- Dump # 1:
 Timer T1 "resource consumption of sin()" (315 rounds):  027c--029e
              Instructions        Ticks
    Total:       411402          541887
    Mean:          1306            1720
    Stand.Dev:     75.5            85.6
    Min:            686            1029
    Max:           1515            1952
    Calls (abs) in [   1,   5] was:   1 now:   1
    Calls (rel) in [   0,   4] was:   0 now:   0
    Stack (abs) in [04f8,04e5] was:04f8 now:04f8
    Stack (rel) in [   0,  19] was:   0 now:   0

           Min round Max round    Min tag           /   Max tag
    Calls           -all-same-                      /
    Stack           -all-same-                      /
    Instr.         1       315     sin (0.00000)    /   sin (3.14000) 
    Ticks          1       315     sin (0.00000)    /   sin (3.14000) 

 Stat  T2 "" (315 Values)
    Mean:       3.589886e-001     round    tag
    Stand.Dev:  5.247231e-001
    Min:        0.000000e+000         1     x=0.00000 
    Max:        2.021442e+000       315     x=3.14000 


The computation of sin (x) took 1029..1952 cycles for the 315 values it had
been computed with an average of 1720 cycles.  sin() needs 19 bytes stack
space.  The maximal difference between sin (x) and the 3rd-order
approximation  x - x^3 / 6  is 2.02144 and occurred for x = 3.14.
